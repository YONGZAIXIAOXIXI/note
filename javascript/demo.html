<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-a818c975-3afa-48a1-ae46-05d674f2932f"></attachment><h2>题目1-二叉树重建</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如输入前序遍历序列<code style="background-color: rgb(243, 244, 244);">{1,2,4,7,3,5,6,8}</code>和中序遍历序列<code style="background-color: rgb(243, 244, 244);">{4,7,2,1,5,3,8,6}</code>，则重建二叉树并返回。</p><h2>思路</h2><ul><li>前序遍历：跟节点 + 左子树前序遍历 + 右子树前序遍历</li><li>中序遍历：左子树中序遍历 + 跟节点 + 右字数中序遍历</li><li>后序遍历：左子树后序遍历 + 右子树后序遍历 + 跟节点</li></ul><p>根据上面的规律：</p><ul><li>前序遍历找到根结点<code style="background-color: rgb(243, 244, 244);">root</code></li><li>找到<code style="background-color: rgb(243, 244, 244);">root</code>在中序遍历的位置 -&gt; 左子树的长度和右子树的长度</li><li>截取左子树的中序遍历、右子树的中序遍历</li><li>截取左子树的前序遍历、右子树的前序遍历</li><li>递归重建二叉树</li></ul><p><span class="ql-font-monospace"><img src="//:0"></span></p><h2>代码</h2><pre class="ql-syntax" spellcheck="false">&nbsp;&nbsp;function reConstructBinaryTree(pre, vin) {
&nbsp;&nbsp;&nbsp;&nbsp;if(pre.length === 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if(pre.length === 1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new TreeNode(pre[0]);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;const value = pre[0];
&nbsp;&nbsp;&nbsp;&nbsp;const index = vin.indexOf(value);
&nbsp;&nbsp;&nbsp;&nbsp;const vinLeft = vin.slice(0,index);
&nbsp;&nbsp;&nbsp;&nbsp;const vinRight = vin.slice(index+1);
&nbsp;&nbsp;&nbsp;&nbsp;const preLeft = pre.slice(1,index+1);
&nbsp;&nbsp;&nbsp;&nbsp;const preRight = pre.slice(index+1);
&nbsp;&nbsp;&nbsp;&nbsp;const node = new TreeNode(value);
&nbsp;&nbsp;&nbsp;&nbsp;node.left = reConstructBinaryTree(preLeft, vinLeft);
&nbsp;&nbsp;&nbsp;&nbsp;node.right = reConstructBinaryTree(preRight, vinRight);
&nbsp;&nbsp;&nbsp;&nbsp;return node;
&nbsp;}
</pre><h2>题目2-求二叉树的遍历</h2><p>给定一棵二叉树的前序遍历和中序遍历，求其后序遍历</p><p>输入描述:</p><p>两个字符串，其长度n均小于等于26。</p><p>第一行为前序遍历，第二行为中序遍历。</p><p>二叉树中的结点名称以大写字母表示：A，B，C....最多26个结点。</p><p>输出描述:</p><p>输入样例可能有多组，对于每组测试样例，</p><p>输出一行，为后序遍历的字符串。</p><p>样例：</p><pre class="ql-syntax" spellcheck="false">输入
ABC
BAC
FDXEAG
XDEFAG
​
输出
BCA
XEDGAF
</pre><h2>思路</h2><p>和上面题目的思路基本相同</p><ul><li>前序遍历找到根结点<code style="background-color: rgb(243, 244, 244);">root</code></li><li>找到<code style="background-color: rgb(243, 244, 244);">root</code>在中序遍历的位置 -&gt; 左子树的长度和右子树的长度</li><li>截取左子树的中序遍历、右子树的中序遍历</li><li>截取左子树的前序遍历、右子树的前序遍历</li><li>递归拼接二叉树的后序遍历</li></ul><h2>代码</h2><pre class="ql-syntax" spellcheck="false">let pre;
let vin;
 
while((pre = readline())!=null){
&nbsp;&nbsp;vin = readline();
&nbsp;&nbsp;print(getHRD(pre,vin));
}
 
&nbsp;&nbsp;function getHRD(pre, vin) {
&nbsp;&nbsp;&nbsp;if (!pre) {
&nbsp;&nbsp;&nbsp;&nbsp;return '';
&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (pre.length === 1) {
&nbsp;&nbsp;&nbsp;&nbsp;return pre;
&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;const head = pre[0];
&nbsp;&nbsp;&nbsp;const splitIndex = vin.indexOf(head);
&nbsp;&nbsp;&nbsp;const vinLeft = vin.substring(0, splitIndex);
&nbsp;&nbsp;&nbsp;const vinRight = vin.substring(splitIndex + 1);
&nbsp;&nbsp;&nbsp;const preLeft = pre.substring(1, splitIndex + 1);
&nbsp;&nbsp;&nbsp;const preRight = pre.substring(splitIndex + 1);
&nbsp;&nbsp;&nbsp;return getHRD(preLeft, vinLeft) + getHRD(preRight, vinRight) + head;
&nbsp;}
</pre><h2>考察点</h2><ul><li>二叉树</li><li>复杂问题拆解</li></ul><p><br></p>